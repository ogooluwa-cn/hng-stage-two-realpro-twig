"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOutputBuffer = void 0;
const createOutputHandler = () => {
    let content = '';
    return {
        getContent: () => {
            return content;
        },
        write: (value) => {
            content = value;
        },
        append: (value) => {
            content += value;
        }
    };
};
const createOutputBuffer = () => {
    const handlers = [];
    const writables = [];
    const outputStream = {
        write: (chunk) => {
            writables.forEach((writable) => writable.write(chunk));
        },
        pipe: (writable) => {
            writables.push(writable);
        }
    };
    /**
     * Append the string to the top-most buffer or write it to the output stream if there is none
     *
     * @param {string} string | void
     */
    const outputWrite = (string) => {
        const active = getActive();
        if (active) {
            active.append(string);
        }
        else {
            outputStream.write(string);
        }
    };
    const getActive = () => {
        if (handlers.length > 0) {
            return handlers[handlers.length - 1];
        }
        else {
            return null;
        }
    };
    const outputBuffer = {
        get outputStream() {
            return outputStream;
        },
        clean: () => {
            const active = getActive();
            if (!active) {
                throw new Error('Failed to clean buffer: no buffer to clean.');
            }
            active.write('');
            return true;
        },
        echo(value) {
            if (typeof value === 'boolean') {
                value = (value === true) ? '1' : '';
            }
            else if (typeof value === "number") {
                value = String(value);
            }
            else if (value === null || value === undefined) {
                value = '';
            }
            return outputWrite(value);
        },
        endAndClean: () => {
            outputBuffer.clean();
            handlers.pop();
            return true;
        },
        endAndFlush: () => {
            if (!getActive()) {
                throw new Error('Failed to delete and flush buffer: no buffer to delete or flush.');
            }
            outputBuffer.flush();
            handlers.pop();
            return true;
        },
        flush: () => {
            let active = getActive();
            if (!active) {
                throw new Error('Failed to flush buffer: no buffer to flush.');
            }
            handlers.pop();
            outputWrite(active.getContent());
            active.write('');
            handlers.push(active);
            return true;
        },
        getAndClean: () => {
            const content = outputBuffer.getContents();
            outputBuffer.endAndClean();
            return content;
        },
        getAndFlush: () => {
            const content = outputBuffer.getContents();
            outputBuffer.endAndFlush();
            return content;
        },
        getContents: () => {
            const activeOutputHandler = getActive();
            return activeOutputHandler ? activeOutputHandler.getContent() : '';
        },
        getLevel: () => {
            return handlers.length;
        },
        start: () => {
            const handler = createOutputHandler();
            handlers.push(handler);
            return true;
        }
    };
    return outputBuffer;
};
exports.createOutputBuffer = createOutputBuffer;
