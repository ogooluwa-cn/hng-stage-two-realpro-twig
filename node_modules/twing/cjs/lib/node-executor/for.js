"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeForNodeSynchronously = exports.executeForNode = void 0;
const ensure_traversable_1 = require("../helpers/ensure-traversable");
const count_1 = require("../helpers/count");
const iterate_1 = require("../helpers/iterate");
const executeForNode = async (forNode, executionContext) => {
    const { context, nodeExecutor: execute } = executionContext;
    const { sequence: sequenceNode, body, else: elseNode, valueTarget: targetValueNode, keyTarget: targetKeyNode } = forNode.children;
    const { hasAnIf } = forNode.attributes;
    context.set('_parent', context.clone());
    const executedSequence = await execute(sequenceNode, executionContext);
    const sequence = (0, ensure_traversable_1.ensureTraversable)(executedSequence);
    context.set('_seq', sequence);
    if (elseNode) {
        context.set('_iterated', false);
    }
    context.set('loop', new Map([
        ['parent', context.get('_parent')],
        ['index0', 0],
        ['index', 1],
        ['first', true],
    ]));
    if (!hasAnIf) {
        const length = (0, count_1.count)(context.get('_seq'));
        const loop = context.get('loop');
        loop.set('revindex0', length - 1);
        loop.set('revindex', length);
        loop.set('length', length);
        loop.set('last', (length === 1));
    }
    const targetKey = await execute(targetKeyNode, executionContext);
    const targetValue = await execute(targetValueNode, executionContext);
    await (0, iterate_1.iterate)(context.get('_seq'), async (key, value) => {
        context.set(targetKey, key);
        context.set(targetValue, value);
        await execute(body, executionContext);
    });
    if (elseNode) {
        if (context.get('_iterated') === false) {
            await execute(elseNode, executionContext);
        }
    }
    const parent = context.get('_parent');
    context.delete('_seq');
    context.delete('_iterated');
    context.delete(targetKeyNode.attributes.name);
    context.delete(targetValueNode.attributes.name);
    context.delete('_parent');
    context.delete('loop');
    for (const [key, value] of parent) {
        if (!context.has(key)) {
            context.set(key, value);
        }
    }
};
exports.executeForNode = executeForNode;
const executeForNodeSynchronously = (forNode, executionContext) => {
    const { context, nodeExecutor: execute } = executionContext;
    const { sequence: sequenceNode, body, else: elseNode, valueTarget: targetValueNode, keyTarget: targetKeyNode } = forNode.children;
    const { hasAnIf } = forNode.attributes;
    context.set('_parent', new Map(context.entries()));
    const executedSequence = execute(sequenceNode, executionContext);
    const sequence = (0, ensure_traversable_1.ensureTraversable)(executedSequence);
    context.set('_seq', sequence);
    if (elseNode) {
        context.set('_iterated', false);
    }
    context.set('loop', new Map([
        ['parent', context.get('_parent')],
        ['index0', 0],
        ['index', 1],
        ['first', true],
    ]));
    if (!hasAnIf) {
        const length = (0, count_1.count)(context.get('_seq'));
        const loop = context.get('loop');
        loop.set('revindex0', length - 1);
        loop.set('revindex', length);
        loop.set('length', length);
        loop.set('last', (length === 1));
    }
    const targetKey = execute(targetKeyNode, executionContext);
    const targetValue = execute(targetValueNode, executionContext);
    (0, iterate_1.iterateSynchronously)(context.get('_seq'), (key, value) => {
        context.set(targetKey, key);
        // todo: @see https://github.com/twigphp/Twig/issues/4152
        if (key === '_parent') {
            context.set(targetValue, '[object Object]');
        }
        else {
            context.set(targetValue, value);
        }
        execute(body, executionContext);
    });
    if (elseNode) {
        if (context.get('_iterated') === false) {
            execute(elseNode, executionContext);
        }
    }
    const parent = context.get('_parent');
    context.delete('_seq');
    context.delete('_iterated');
    context.delete(targetKeyNode.attributes.name);
    context.delete(targetValueNode.attributes.name);
    context.delete('_parent');
    context.delete('loop');
    for (const [key, value] of parent) {
        if (!context.has(key)) {
            context.set(key, value);
        }
    }
};
exports.executeForNodeSynchronously = executeForNodeSynchronously;
