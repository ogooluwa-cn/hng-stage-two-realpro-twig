"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeImportNodeSynchronously = exports.executeImportNode = void 0;
const traceable_method_1 = require("../helpers/traceable-method");
const executeImportNode = async (node, executionContext) => {
    const { template, aliases, nodeExecutor: execute, } = executionContext;
    const { alias: aliasNode, templateName: templateNameNode } = node.children;
    const { global } = node.attributes;
    let aliasValue;
    if (templateNameNode.type === "name" && templateNameNode.attributes.name === '_self') {
        aliasValue = template;
    }
    else {
        const templateName = await execute(templateNameNode, executionContext);
        const loadTemplate = (0, traceable_method_1.getTraceableMethod)(template.loadTemplate, node, template.source);
        aliasValue = await loadTemplate(executionContext, templateName);
    }
    aliases.set(aliasNode.attributes.name, aliasValue);
    if (global) {
        template.aliases.set(aliasNode.attributes.name, aliasValue);
    }
};
exports.executeImportNode = executeImportNode;
const executeImportNodeSynchronously = (node, executionContext) => {
    const { template, aliases, nodeExecutor: execute, } = executionContext;
    const { alias: aliasNode, templateName: templateNameNode } = node.children;
    const { global } = node.attributes;
    let aliasValue;
    if (templateNameNode.type === "name" && templateNameNode.attributes.name === '_self') {
        aliasValue = template;
    }
    else {
        const templateName = execute(templateNameNode, executionContext);
        const loadTemplate = (0, traceable_method_1.getSynchronousTraceableMethod)(template.loadTemplate, node, template.source);
        aliasValue = loadTemplate(executionContext, templateName);
    }
    aliases[aliasNode.attributes.name] = aliasValue;
    if (global) {
        template.aliases[aliasNode.attributes.name] = aliasValue;
    }
};
exports.executeImportNodeSynchronously = executeImportNodeSynchronously;
