"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeSynchronousBlockFunction = exports.executeBlockFunction = void 0;
const traceable_method_1 = require("../../helpers/traceable-method");
const executeBlockFunction = async (node, executionContext) => {
    const { template, context, nodeExecutor: execute, blocks, outputBuffer } = executionContext;
    const { template: templateNode, name: blockNameNode } = node.children;
    const blockName = await execute(blockNameNode, executionContext);
    let resolveTemplate;
    if (templateNode) {
        const templateName = await execute(templateNode, executionContext);
        const loadTemplate = (0, traceable_method_1.getTraceableMethod)(template.loadTemplate, templateNode, template.source);
        resolveTemplate = loadTemplate(executionContext, templateName);
    }
    else {
        resolveTemplate = Promise.resolve(template);
    }
    return resolveTemplate
        .then((templateOfTheBlock) => {
        if (node.attributes.shouldTestExistence) {
            const hasBlock = (0, traceable_method_1.getTraceableMethod)(templateOfTheBlock.hasBlock, node, template.source);
            return hasBlock(Object.assign(Object.assign({}, executionContext), { context: context.clone() }), blockName, blocks);
        }
        else {
            const displayBlock = (0, traceable_method_1.getTraceableMethod)(templateOfTheBlock.displayBlock, node, template.source);
            let useBlocks = templateNode === undefined;
            outputBuffer.start();
            return displayBlock(Object.assign(Object.assign({}, executionContext), { context: context.clone() }), blockName, useBlocks).then(() => {
                return outputBuffer.getAndClean();
            });
        }
    });
};
exports.executeBlockFunction = executeBlockFunction;
const executeSynchronousBlockFunction = (node, executionContext) => {
    const { template, context, nodeExecutor: execute, blocks, outputBuffer } = executionContext;
    const { template: templateNode, name: blockNameNode } = node.children;
    const blockName = execute(blockNameNode, executionContext);
    let templateOfTheBlock;
    if (templateNode) {
        const templateName = execute(templateNode, executionContext);
        const loadTemplate = (0, traceable_method_1.getSynchronousTraceableMethod)(template.loadTemplate, templateNode, template.source);
        templateOfTheBlock = loadTemplate(executionContext, templateName);
    }
    else {
        templateOfTheBlock = template;
    }
    if (node.attributes.shouldTestExistence) {
        const hasBlock = (0, traceable_method_1.getSynchronousTraceableMethod)(templateOfTheBlock.hasBlock, node, template.source);
        return hasBlock(Object.assign(Object.assign({}, executionContext), { context: new Map(context.entries()) }), blockName, blocks);
    }
    else {
        const displayBlock = (0, traceable_method_1.getSynchronousTraceableMethod)(templateOfTheBlock.displayBlock, node, template.source);
        let useBlocks = templateNode === undefined;
        outputBuffer.start();
        displayBlock(Object.assign(Object.assign({}, executionContext), { context: new Map(context.entries()) }), blockName, useBlocks);
        return outputBuffer.getAndClean();
    }
};
exports.executeSynchronousBlockFunction = executeSynchronousBlockFunction;
