"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeMethodCallSynchronously = exports.executeMethodCall = void 0;
const runtime_1 = require("../../error/runtime");
const get_key_value_pairs_1 = require("../../helpers/get-key-value-pairs");
const executeMethodCall = async (node, executionContext) => {
    const { template, aliases, nodeExecutor: execute } = executionContext;
    const { methodName, shouldTestExistence } = node.attributes;
    const { operand, arguments: methodArguments } = node.children;
    if (shouldTestExistence) {
        return aliases.get(operand.attributes.name).hasMacro(methodName);
    }
    else {
        const keyValuePairs = (0, get_key_value_pairs_1.getKeyValuePairs)(methodArguments);
        const macroArguments = [];
        for (const { value: valueNode } of keyValuePairs) {
            const value = await execute(valueNode, executionContext);
            macroArguments.push(value);
        }
        // by nature, the alias exists - the parser only creates a method call node when the name _is_ an alias.
        const macroTemplate = aliases.get(operand.attributes.name);
        const getHandler = (template) => {
            const macroHandler = template.macroHandlers.get(methodName);
            if (macroHandler) {
                return Promise.resolve(macroHandler);
            }
            else {
                return template.getParent(executionContext)
                    .then((parent) => {
                    if (parent) {
                        return getHandler(parent);
                    }
                    else {
                        return null;
                    }
                });
            }
        };
        return getHandler(macroTemplate)
            .then((handler) => {
            if (handler) {
                return handler(executionContext, ...macroArguments);
            }
            else {
                throw (0, runtime_1.createRuntimeError)(`Macro "${methodName}" is not defined in template "${macroTemplate.name}".`, node, template.source);
            }
        });
    }
};
exports.executeMethodCall = executeMethodCall;
const executeMethodCallSynchronously = (node, executionContext) => {
    const { template, aliases, nodeExecutor: execute } = executionContext;
    const { methodName, shouldTestExistence } = node.attributes;
    const { operand, arguments: methodArguments } = node.children;
    if (shouldTestExistence) {
        return aliases[operand.attributes.name].hasMacro(methodName);
    }
    else {
        const keyValuePairs = (0, get_key_value_pairs_1.getKeyValuePairs)(methodArguments);
        const macroArguments = [];
        for (const { value: valueNode } of keyValuePairs) {
            const value = execute(valueNode, executionContext);
            macroArguments.push(value);
        }
        // by nature, the alias exists - the parser only creates a method call node when the name _is_ an alias.
        const macroTemplate = aliases[operand.attributes.name];
        const getHandler = (template) => {
            const macroHandler = template.macroHandlers.get(methodName);
            if (macroHandler) {
                return macroHandler;
            }
            else {
                const parent = template.getParent(executionContext);
                if (parent) {
                    return getHandler(parent);
                }
                else {
                    return null;
                }
            }
        };
        const handler = getHandler(macroTemplate);
        if (handler) {
            return handler(executionContext, ...macroArguments);
        }
        else {
            throw (0, runtime_1.createRuntimeError)(`Macro "${methodName}" is not defined in template "${macroTemplate.name}".`, node, template.source);
        }
    }
};
exports.executeMethodCallSynchronously = executeMethodCallSynchronously;
