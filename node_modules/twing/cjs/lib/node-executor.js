"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeNodeSynchronously = exports.executeNode = void 0;
const binary_1 = require("./node-executor/expression/binary");
const template_1 = require("./node-executor/template");
const print_1 = require("./node-executor/print");
const text_1 = require("./node-executor/text");
const call_1 = require("./node-executor/expression/call");
const method_call_1 = require("./node-executor/expression/method-call");
const assignment_1 = require("./node-executor/expression/assignment");
const import_1 = require("./node-executor/import");
const parent_function_1 = require("./node-executor/expression/parent-function");
const block_function_1 = require("./node-executor/expression/block-function");
const block_reference_1 = require("./node-executor/block-reference");
const unary_1 = require("./node-executor/expression/unary");
const array_1 = require("./node-executor/expression/array");
const hash_1 = require("./node-executor/expression/hash");
const attribute_accessor_1 = require("./node-executor/expression/attribute-accessor");
const name_1 = require("./node-executor/expression/name");
const set_1 = require("./node-executor/set");
const if_1 = require("./node-executor/if");
const for_1 = require("./node-executor/for");
const for_loop_1 = require("./node-executor/for-loop");
const check_to_string_1 = require("./node-executor/check-to-string");
const conditional_1 = require("./node-executor/expression/conditional");
const embed_1 = require("./node-executor/include/embed");
const include_1 = require("./node-executor/include/include");
const with_1 = require("./node-executor/with");
const spaceless_1 = require("./node-executor/spaceless");
const apply_1 = require("./node-executor/apply");
const escape_1 = require("./node-executor/expression/escape");
const arrow_function_1 = require("./node-executor/expression/arrow-function");
const sandbox_1 = require("./node-executor/sandbox");
const do_1 = require("./node-executor/do");
const deprecated_1 = require("./node-executor/deprecated");
const spread_1 = require("./node-executor/expression/spread");
const check_security_1 = require("./node-executor/check-security");
const flush_1 = require("./node-executor/flush");
const runtime_1 = require("./error/runtime");
const constant_1 = require("./node-executor/constant");
const line_1 = require("./node-executor/line");
const comment_1 = require("./node-executor/comment");
const base_1 = require("./node-executor/base");
const binaryNodeTypes = ["add", "and", "bitwise_and", "bitwise_or", "bitwise_xor", "concatenate", "divide", "divide_and_floor", "ends_with", "has_every", "has_some", "is_equal_to", "is_greater_than", "is_greater_than_or_equal_to", "is_in", "is_less_than", "is_less_than_or_equal_to", "is_not_equal_to", "is_not_in", "matches", "modulo", "multiply", "or", "power", "range", "spaceship", "starts_with", "subtract"];
const isABinaryNode = (node) => {
    return binaryNodeTypes.includes(node.type);
};
const unaryNodeTypes = ["negative", "not", "positive"];
const isAUnaryNode = (node) => {
    return unaryNodeTypes.includes(node.type);
};
const callNodeTypes = ["filter", "function", "test"];
const isACallNode = (node) => {
    return callNodeTypes.includes(node.type);
};
/**
 * Execute the passed node against the passed execution context.
 *
 * @param node The node to execute
 * @param executionContext The context the node is executed against
 */
const executeNode = (node, executionContext) => {
    let executor;
    if (isABinaryNode(node)) {
        executor = binary_1.executeBinaryNode;
    }
    else if (isACallNode(node)) {
        executor = call_1.executeCallNode;
    }
    else if (isAUnaryNode(node)) {
        executor = unary_1.executeUnaryNode;
    }
    else if (node.type === null) {
        executor = base_1.executeBaseNode;
    }
    else if (node.type === "apply") {
        executor = apply_1.executeApplyNode;
    }
    else if (node.type === "array") {
        executor = array_1.executeArrayNode;
    }
    else if (node.type === "arrow_function") {
        executor = arrow_function_1.executeArrowFunctionNode;
    }
    else if (node.type === "assignment") {
        executor = assignment_1.executeAssignmentNode;
    }
    else if (node.type === "attribute_accessor") {
        executor = attribute_accessor_1.executeAttributeAccessorNode;
    }
    else if (node.type === "block_function") {
        executor = block_function_1.executeBlockFunction;
    }
    else if (node.type === "block_reference") {
        executor = block_reference_1.executeBlockReferenceNode;
    }
    else if (node.type === "check_security") {
        executor = check_security_1.executeCheckSecurityNode;
    }
    else if (node.type === "check_to_string") {
        executor = check_to_string_1.executeCheckToStringNode;
    }
    else if (node.type === "comment") {
        executor = comment_1.executeCommentNode;
    }
    else if (node.type === "conditional") {
        executor = conditional_1.executeConditionalNode;
    }
    else if (node.type === "constant") {
        executor = constant_1.executeConstantNode;
    }
    else if (node.type === "deprecated") {
        executor = deprecated_1.executeDeprecatedNode;
    }
    else if (node.type === "do") {
        executor = do_1.executeDoNode;
    }
    else if (node.type === "embed") {
        executor = embed_1.executeEmbedNode;
    }
    else if (node.type === "escape") {
        executor = escape_1.executeEscapeNode;
    }
    else if (node.type === "flush") {
        executor = flush_1.executeFlushNode;
    }
    else if (node.type === "for") {
        executor = for_1.executeForNode;
    }
    else if (node.type === "for_loop") {
        executor = for_loop_1.executeForLoopNode;
    }
    else if (node.type === "hash") {
        executor = hash_1.executeHashNode;
    }
    else if (node.type === "if") {
        executor = if_1.executeIfNode;
    }
    else if (node.type === "import") {
        executor = import_1.executeImportNode;
    }
    else if (node.type === "include") {
        executor = include_1.executeIncludeNode;
    }
    else if (node.type === "line") {
        executor = line_1.executeLineNode;
    }
    else if (node.type === "method_call") {
        executor = method_call_1.executeMethodCall;
    }
    else if (node.type === "name") {
        executor = name_1.executeNameNode;
    }
    else if (node.type === "nullish_coalescing") {
        executor = conditional_1.executeConditionalNode;
    }
    else if (node.type === "parent_function") {
        executor = parent_function_1.executeParentFunction;
    }
    else if (node.type === "print") {
        executor = print_1.executePrintNode;
    }
    else if (node.type === "sandbox") {
        executor = sandbox_1.executeSandboxNode;
    }
    else if (node.type === "set") {
        executor = set_1.executeSetNode;
    }
    else if (node.type === "spaceless") {
        executor = spaceless_1.executeSpacelessNode;
    }
    else if (node.type === "spread") {
        executor = spread_1.executeSpreadNode;
    }
    else if (node.type === "template") {
        executor = template_1.executeTemplateNode;
    }
    else if (node.type === "text") {
        executor = text_1.executeTextNode;
    }
    else if (node.type === "verbatim") {
        executor = text_1.executeTextNode;
    }
    else if (node.type === "with") {
        executor = with_1.executeWithNode;
    }
    else {
        return Promise.reject((0, runtime_1.createRuntimeError)(`Unrecognized node of type "${node.type}"`, node, executionContext.template.source));
    }
    return executor(node, executionContext);
};
exports.executeNode = executeNode;
const executeNodeSynchronously = (node, executionContext) => {
    let executor;
    if (isABinaryNode(node)) {
        executor = binary_1.executeBinaryNodeSynchronously;
    }
    else if (isACallNode(node)) {
        executor = call_1.executeCallNodeSynchronously;
    }
    else if (isAUnaryNode(node)) {
        executor = unary_1.executeUnaryNodeSynchronously;
    }
    else if (node.type === null) {
        executor = base_1.executeBaseNodeSynchronously;
    }
    else if (node.type === "apply") {
        executor = apply_1.executeApplyNodeSynchronously;
    }
    else if (node.type === "array") {
        executor = array_1.executeArrayNodeSynchronously;
    }
    else if (node.type === "arrow_function") {
        executor = arrow_function_1.executeArrowFunctionNodeSynchronously;
    }
    else if (node.type === "assignment") {
        executor = assignment_1.executeAssignmentNodeSynchronously;
    }
    else if (node.type === "attribute_accessor") {
        executor = attribute_accessor_1.executeAttributeAccessorNodeSynchronously;
    }
    else if (node.type === "block_function") {
        executor = block_function_1.executeSynchronousBlockFunction;
    }
    else if (node.type === "block_reference") {
        executor = block_reference_1.executeBlockReferenceNodeSynchronously;
    }
    else if (node.type === "check_security") {
        executor = check_security_1.executeCheckSecurityNodeSynchronously;
    }
    else if (node.type === "check_to_string") {
        executor = check_to_string_1.executeCheckToStringNodeSynchronously;
    }
    else if (node.type === "comment") {
        executor = comment_1.executeCommentNodeSynchronously;
    }
    else if (node.type === "conditional") {
        executor = conditional_1.executeConditionalNodeSynchronously;
    }
    else if (node.type === "constant") {
        executor = constant_1.executeConstantNodeSynchronously;
    }
    else if (node.type === "deprecated") {
        executor = deprecated_1.executeDeprecatedNodeSynchronously;
    }
    else if (node.type === "do") {
        executor = do_1.executeDoNodeSynchronously;
    }
    else if (node.type === "embed") {
        executor = embed_1.executeEmbedNodeSynchronously;
    }
    else if (node.type === "escape") {
        executor = escape_1.executeEscapeNodeSynchronously;
    }
    else if (node.type === "flush") {
        executor = flush_1.executeFlushNodeSynchronously;
    }
    else if (node.type === "for") {
        executor = for_1.executeForNodeSynchronously;
    }
    else if (node.type === "for_loop") {
        executor = for_loop_1.executeForLoopNodeSynchronously;
    }
    else if (node.type === "hash") {
        executor = hash_1.executeHashNodeSynchronously;
    }
    else if (node.type === "if") {
        executor = if_1.executeIfNodeSynchronously;
    }
    else if (node.type === "import") {
        executor = import_1.executeImportNodeSynchronously;
    }
    else if (node.type === "include") {
        executor = include_1.executeIncludeNodeSynchronously;
    }
    else if (node.type === "line") {
        executor = line_1.executeLineNodeSynchronously;
    }
    else if (node.type === "method_call") {
        executor = method_call_1.executeMethodCallSynchronously;
    }
    else if (node.type === "name") {
        executor = name_1.executeNameNodeSynchronously;
    }
    else if (node.type === "nullish_coalescing") {
        executor = conditional_1.executeConditionalNodeSynchronously;
    }
    else if (node.type === "parent_function") {
        executor = parent_function_1.executeParentFunctionSynchronously;
    }
    else if (node.type === "print") {
        executor = print_1.executePrintNodeSynchronously;
    }
    else if (node.type === "sandbox") {
        executor = sandbox_1.executeSandboxNodeSynchronously;
    }
    else if (node.type === "set") {
        executor = set_1.executeSetNodeSynchronously;
    }
    else if (node.type === "spaceless") {
        executor = spaceless_1.executeSpacelessNodeSynchronously;
    }
    else if (node.type === "spread") {
        executor = spread_1.executeSpreadNodeSynchronously;
    }
    else if (node.type === "template") {
        executor = template_1.executeTemplateNodeSynchronously;
    }
    else if (node.type === "text") {
        executor = text_1.executeTextNodeSynchronously;
    }
    else if (node.type === "verbatim") {
        executor = text_1.executeTextNodeSynchronously;
    }
    else if (node.type === "with") {
        executor = with_1.executeWithNodeSynchronously;
    }
    else {
        throw (0, runtime_1.createRuntimeError)(`Unrecognized node of type "${node.type}"`, node, executionContext.template.source);
    }
    return executor(node, executionContext);
};
exports.executeNodeSynchronously = executeNodeSynchronously;
