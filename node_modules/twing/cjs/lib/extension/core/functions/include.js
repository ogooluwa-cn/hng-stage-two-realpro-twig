"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.includeSynchronously = exports.include = void 0;
const is_traversable_1 = require("../../../helpers/is-traversable");
const is_plain_object_1 = require("../../../helpers/is-plain-object");
const context_1 = require("../../../context");
const markup_1 = require("../../../markup");
const template_1 = require("../../../template");
const iterator_to_map_1 = require("../../../helpers/iterator-to-map");
const merge_iterables_1 = require("../../../helpers/merge-iterables");
/**
 * Renders a template.
 *
 * @param executionContext
 * @param templates The template to render or an array of templates to try consecutively
 * @param variables The variables to pass to the template
 * @param withContext
 * @param ignoreMissing Whether to ignore missing templates or not
 * @param sandboxed
 *
 * @returns {Promise<TwingMarkup>} The rendered template
 */
const include = (executionContext, templates, variables, withContext, ignoreMissing, sandboxed) => {
    const { template, environment, templateLoader, context, nodeExecutor, outputBuffer, sourceMapRuntime, strict } = executionContext;
    if (!(0, is_plain_object_1.isPlainObject)(variables) && !(0, is_traversable_1.isTraversable)(variables)) {
        const isVariablesNullOrUndefined = variables === null || variables === undefined;
        return Promise.reject(new Error(`Variables passed to the "include" function or tag must be iterable, got "${!isVariablesNullOrUndefined ? typeof variables : variables}".`));
    }
    variables = (0, iterator_to_map_1.iteratorToMap)(variables);
    if (withContext) {
        variables = (0, merge_iterables_1.mergeIterables)(context, variables);
    }
    if (!Array.isArray(templates)) {
        templates = [templates];
    }
    const resolveTemplate = (templates) => {
        return template.loadTemplate(executionContext, templates)
            .catch((error) => {
            if (error.name === "TwingParsingError") {
                throw error;
            }
            if (!ignoreMissing) {
                throw error;
            }
            else {
                return null;
            }
        });
    };
    return resolveTemplate(templates)
        .then((template) => {
        outputBuffer.start();
        if (template) {
            return template.execute(environment, (0, context_1.createContext)((0, iterator_to_map_1.iterableToMap)(variables)), new Map(), outputBuffer, {
                nodeExecutor,
                sandboxed,
                sourceMapRuntime: sourceMapRuntime || undefined,
                strict,
                templateLoader
            });
        }
        else {
            return Promise.resolve();
        }
    })
        .then(() => {
        const result = outputBuffer.getAndClean();
        return (0, markup_1.createMarkup)(result, environment.charset);
    });
};
exports.include = include;
const includeSynchronously = (executionContext, templates, variables, withContext, ignoreMissing, sandboxed) => {
    const { template, environment, templateLoader, context, nodeExecutor, outputBuffer, sourceMapRuntime, strict } = executionContext;
    if (!(0, is_plain_object_1.isPlainObject)(variables) && !(0, is_traversable_1.isTraversable)(variables)) {
        const isVariablesNullOrUndefined = variables === null || variables === undefined;
        throw new Error(`Variables passed to the "include" function or tag must be iterable, got "${!isVariablesNullOrUndefined ? typeof variables : variables}".`);
    }
    variables = (0, iterator_to_map_1.iteratorToMap)(variables);
    if (withContext) {
        variables = new Map([
            ...context.entries(),
            ...variables.entries()
        ]);
    }
    if (!Array.isArray(templates)) {
        templates = [templates];
    }
    const resolveTemplate = (templates) => {
        try {
            return template.loadTemplate(executionContext, templates);
        }
        catch (error) {
            if (error.name === "TwingParsingError") {
                throw error;
            }
            if (!ignoreMissing) {
                throw error;
            }
            else {
                return null;
            }
        }
    };
    const resolvedTemplate = resolveTemplate(templates);
    outputBuffer.start();
    if (resolvedTemplate) {
        (0, template_1.executeSynchronousTemplate)(resolvedTemplate, environment, variables, new Map(), outputBuffer, {
            nodeExecutor,
            sandboxed,
            sourceMapRuntime: sourceMapRuntime || undefined,
            strict,
            templateLoader
        });
    }
    const result = outputBuffer.getAndClean();
    return (0, markup_1.createMarkup)(result, environment.charset);
};
exports.includeSynchronously = includeSynchronously;
