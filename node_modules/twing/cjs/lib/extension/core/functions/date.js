"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateSynchronously = exports.createDateTimeSynchronously = exports.date = exports.createDateTime = void 0;
const luxon_1 = require("luxon");
const modify_date_1 = require("../../../helpers/modify-date");
/**
 * Converts an input to a DateTime instance.
 *
 * <pre>
 *    {% if date(user.created_at) < date('+2days') %}
 *      {# do something #}
 *    {% endif %}
 * </pre>
 *
 * @param {TwingTemplate} template
 * @param {Date | DateTime | Duration | number | string} input A date or null to use the current time
 * @param {string | null | boolean} timezone The target timezone, null to use the default, false to leave unchanged
 *
 * @returns {Promise<DateTime | Duration>}
 */
const createDateTime = (defaultTimezone, input, timezone) => {
    const _do = () => {
        let result;
        if (input === null) {
            result = luxon_1.DateTime.local();
        }
        else if (typeof input === 'number') {
            result = luxon_1.DateTime.fromMillis(input * 1000);
        }
        else if (typeof input === 'string') {
            if (input === 'now') {
                result = luxon_1.DateTime.local();
            }
            else {
                result = luxon_1.DateTime.fromISO(input, {
                    setZone: true
                });
                if (!result.isValid) {
                    result = luxon_1.DateTime.fromRFC2822(input, {
                        setZone: true
                    });
                }
                if (!result.isValid) {
                    result = luxon_1.DateTime.fromSQL(input, {
                        setZone: true
                    });
                }
                if (!result.isValid && /^-{0,1}\d+$/.test(input)) {
                    result = luxon_1.DateTime.fromMillis(Number.parseInt(input) * 1000, {
                        setZone: true
                    });
                }
                if (!result.isValid) {
                    result = (0, modify_date_1.modifyDate)(input);
                }
            }
        }
        else if (input instanceof luxon_1.DateTime) {
            result = input;
        }
        else {
            result = luxon_1.DateTime.fromJSDate(input);
        }
        if (!result || !result.isValid) {
            throw new Error(`Failed to parse date "${input}".`);
        }
        // now let's apply timezone
        // determine the timezone
        if (timezone !== false) {
            if (timezone === null) {
                timezone = defaultTimezone;
            }
            result = result.setZone(timezone);
        }
        return result;
    };
    try {
        return Promise.resolve(_do());
    }
    catch (e) {
        return Promise.reject(e);
    }
};
exports.createDateTime = createDateTime;
const date = (executionContext, date, timezone) => {
    if (date instanceof luxon_1.Duration) {
        return Promise.resolve(date);
    }
    return (0, exports.createDateTime)(executionContext.environment.timezone, date, timezone);
};
exports.date = date;
const createDateTimeSynchronously = (defaultTimezone, input, timezone) => {
    let result;
    if (input === null) {
        result = luxon_1.DateTime.local();
    }
    else if (typeof input === 'number') {
        result = luxon_1.DateTime.fromMillis(input * 1000);
    }
    else if (typeof input === 'string') {
        if (input === 'now') {
            result = luxon_1.DateTime.local();
        }
        else {
            result = luxon_1.DateTime.fromISO(input, {
                setZone: true
            });
            if (!result.isValid) {
                result = luxon_1.DateTime.fromRFC2822(input, {
                    setZone: true
                });
            }
            if (!result.isValid) {
                result = luxon_1.DateTime.fromSQL(input, {
                    setZone: true
                });
            }
            if (!result.isValid && /^-{0,1}\d+$/.test(input)) {
                result = luxon_1.DateTime.fromMillis(Number.parseInt(input) * 1000, {
                    setZone: true
                });
            }
            if (!result.isValid) {
                result = (0, modify_date_1.modifyDate)(input);
            }
        }
    }
    else if (input instanceof luxon_1.DateTime) {
        result = input;
    }
    else {
        result = luxon_1.DateTime.fromJSDate(input);
    }
    if (!result || !result.isValid) {
        throw new Error(`Failed to parse date "${input}".`);
    }
    // now let's apply timezone
    // determine the timezone
    if (timezone !== false) {
        if (timezone === null) {
            timezone = defaultTimezone;
        }
        result = result.setZone(timezone);
    }
    return result;
};
exports.createDateTimeSynchronously = createDateTimeSynchronously;
const dateSynchronously = (executionContext, date, timezone) => {
    if (date instanceof luxon_1.Duration) {
        return date;
    }
    return (0, exports.createDateTimeSynchronously)(executionContext.environment.timezone, date, timezone);
};
exports.dateSynchronously = dateSynchronously;
