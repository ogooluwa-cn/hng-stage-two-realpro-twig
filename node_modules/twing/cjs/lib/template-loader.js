"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSynchronousTemplateLoader = exports.createTemplateLoader = void 0;
const template_1 = require("./template");
const createTemplateLoader = (environment) => {
    const registry = new Map();
    return async (name, from) => {
        const { loader } = environment;
        let templateFqn = await loader.resolve(name, from) || name;
        let loadedTemplate = registry.get(templateFqn);
        if (loadedTemplate) {
            return Promise.resolve(loadedTemplate);
        }
        else {
            const { cache } = environment;
            const timestamp = cache ? await cache.getTimestamp(templateFqn) : 0;
            const getAstFromCache = async () => {
                if (cache === null) {
                    return Promise.resolve(null);
                }
                let content;
                const isFresh = await loader.isFresh(name, timestamp, from);
                if (isFresh) {
                    content = await cache.load(templateFqn);
                }
                else {
                    content = null;
                }
                return content;
            };
            const getAstFromLoader = async () => {
                const source = await loader.getSource(name, from);
                if (source === null) {
                    return null;
                }
                const ast = environment.parse(environment.tokenize(source));
                if (cache !== null) {
                    await cache.write(templateFqn, ast);
                }
                return ast;
            };
            let ast = await getAstFromCache();
            if (ast === null) {
                ast = await getAstFromLoader();
            }
            if (ast === null) {
                return null;
            }
            const template = (0, template_1.createTemplate)(ast);
            registry.set(templateFqn, template);
            return template;
        }
    };
};
exports.createTemplateLoader = createTemplateLoader;
const createSynchronousTemplateLoader = (environment) => {
    const registry = new Map();
    return (name, from) => {
        const { loader } = environment;
        let templateFqn = loader.resolve(name, from) || name;
        let loadedTemplate = registry.get(templateFqn);
        if (loadedTemplate) {
            return loadedTemplate;
        }
        else {
            const { cache } = environment;
            const timestamp = cache ? cache.getTimestamp(templateFqn) : 0;
            const getAstFromCache = () => {
                if (cache === null) {
                    return null;
                }
                let content;
                const isFresh = loader.isFresh(name, timestamp, from);
                if (isFresh) {
                    content = cache.load(templateFqn);
                }
                else {
                    content = null;
                }
                return content;
            };
            const getAstFromLoader = () => {
                const source = loader.getSource(name, from);
                if (source === null) {
                    return null;
                }
                const ast = environment.parse(environment.tokenize(source));
                if (cache !== null) {
                    cache.write(templateFqn, ast);
                }
                return ast;
            };
            let ast = getAstFromCache();
            if (ast === null) {
                ast = getAstFromLoader();
            }
            if (ast === null) {
                return null;
            }
            const template = (0, template_1.createSynchronousTemplate)(ast);
            registry.set(templateFqn, template);
            return template;
        }
    };
};
exports.createSynchronousTemplateLoader = createSynchronousTemplateLoader;
